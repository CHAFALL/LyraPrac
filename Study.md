# Lyra 공부

## 잡다한 것

##### 모듈/ 플러그인/ 프로젝트 차이점?

- 모듈 : .cpp 랑 .h를 포함하는 최소 단위
- 플러그인 : 독자적으로 구성을 할 수 x, 여러 모듈을 묶어서 구성할 수 있는데 실험적인 기능이라던가 외부 확장 용도로 사용할 수 있을 때 이용됨
- 프로젝트 : 모듈과 플러그인 + 컨텐츠을 포함하는 단위, 프로젝트에서 원하는 모듈을 포함할 지 말지를 결정가능
- 모듈이랑 플러그인의 차이점은? 에픽게임즈에서 실험적인 기능들은 플러그인으로 테스트하다가 안정성이 높다고 판단이 되면 그때 엔진의 모듈로 옮김 

##### 동기 비동기 차이점

- 동기 : 내가 시킨 로딩을 완료하기 전까지 절대로 다음 함수로 넘어가지 않음

- 비동기 : 로딩을 하는데 (시간이 많이 걸릴 것 같으면) 일단 나와서 (내부적으로 다른 쓰레드 또는 어떠한 방식을 통해서 따로 로딩을 돌림) 다음 함수로 넘어갈 수 있도록 함

- 게임은 당연히 비동기를 많이 이용!

- 동기식의 장점 : 비동기보다 속도가 빠름

- 비동기식의 단점 : 여러개가 있으면 우리가 로직 순서를 파악하기 힘듬.

- 그래서 게임 들어가기 전 로딩때는 동기식 로딩을 많이 이용

- SynchronousLoadAsset을 따로 함수로 만든 이유? 인게임 중에 동기 로딩이 많아지면 그만큼 프레임드랍이 발생할텐데 어디서 문제가 나는지 동기 로딩에서 문제가 생기는지 찾기 위해서 따로 함수를 만듬

##### Asset, TSubclassOf, CDO, StaticClass가 무엇인가?

- Asset : 게임에서 사용되는 모든 콘텐츠 파일들 (텍스처, 메시, 블루프린트, 사우드 등)

- TSubclassOf : 특정 클래스의 자식 클래스만 참조할 수 있게 제한하는 템플릿 클래스, 타입을 안전하게 저장하도록 해줌

- CDO : 클래스당 하나만 존재하는 기본 객체로, 두 가지 주요 역할을 수행 (기본값을 저장하는 U 오브젝트라고 생각해도 됨)
  
  - 새로운 인스턴스 생성 시 기본 프로퍼티 값의 템플릿으로 사용됩니다.
  
  - 델타 시리얼라이제이션의 기준점이 되어, 객체를 저장할 때 CDO와 다른 값만 저장함으로써 저장 용량을 절약합니다.
    
    - 데디를 생각한다면 네트워크 상에서 바뀐 부분만 보내주면 되어서 Good

- StaticClass : 메타데이터(리플렉션) 
  
  - 여기서 리플렉션이란? 런타임 단계에서 클래스에 대한 정보를 알 수 있도록 하는 것
  
  - ex. 어떤 함수를 통해서 클래스의 정보를 가져올 수 있음, 수정도 되네.. (C++은 안됨, 그래서 언리얼 엔진에서는 generated.h 이걸 통해서 강제로 만들어줬음(C# 기능임.)
  
  - (참고) 리플렉션을 활성화하는 매크로들 : UCLASS(), GENERATED_BODY(), UPROPERTY(), UFUNCTION()
  
  - 어떤 변수가 있는지 알고 변수의 이름 이런 것들을 저장하고 있는 게 UCLASS이다.

##### Experience

- (기존) FPS -> AOS로 넘어가려면 게임모드를 변경, 게임모드는 굉장히 무거움....

- 그래서 탄생.

- 게임의 특정 부분이나 모드를 정의하는 컨테이너.

##### Primary Asset 관리

- 자동으로 감지되어야 하지만, 안 될시에 Asset Manager에서 스캔 등록을 해줬는지 의심해보자!

##### PlayerCameraManager와 CameraComponent의 차이점

- PlayerCameraManager
  
  - 실질적으로 보이는 시야를 결정
  
  - 게임의 전반적인 카메라 시스템을 관리하고 제어

- CameraComponent
  
  - 특정 액터의 시점 정보를 제공하는 것이 주 목적
  - 캐릭터의 시야를 캡처하지만, 직접 렌더링하지 않음
  - 대신 캡처한 시점 정보를 PlayerCameraManager에 전달하여 최종 출력을 담당하게 함

- CameraComponent가 직접 렌더링하지 않는 이유
  
  - 플레이어 컨트롤러는 게임 중 다른 캐릭터로 자유롭게 전환될 수 있음
  - 이러한 유연성을 지원하기 위해 카메라 시스템이 특정 캐릭터에 종속되지 않아야 함
  - 따라서 PlayerController 내부에 CameraManager를 두어 캐릭터 독립적인 카메라 시스템을 구현

##### 입력 방식이 바뀐 이유 (Input Mapping Context가 생긴 이유)

- 기존 : 예전에는 하나의 Input Action에서 여러 게임 상태(비행기 모드, 탱크 모드 등)에 따른 분기 처리

- Input Mapping Context를 통해 각 게임 상태별로 입력을 완전히 분리가능!!!
  
  - 여러 조건문을 관리할 필요가 사라짐!!

##### 입력 관련 내용

- Input Action
  
  - 게임에서 수행할 수 있는 추상적인 동작을 정의
  
  - **입력값의 타입을 지정**

- Input Mapping Context
  
  - Input Action과 실제 물리적 입력(키보드, 마우스, 게임패드 등)을 매핑하는 곳
  
  - 같은 Input Action이라도 상황에 따라 다른 키에 매핑 가능

- 즉 Input Action은 "무엇을 할 것인가"를 정의하고, Input Mapping Context는 "어떤 키로 할 것인가"를 정의한다고 보면 됨.

##### Subsystem과 싱글톤의 차이

- 싱글톤 패턴 
  
  - 장점 : 
    
    - 인스턴스의 고유성 보장
    
    - 전역 접근이 가능 (getInstance())
    
    - 한 번의 객체 생성으로 메모리 절약 가능
  
  - 단점 : 
    
    - 한번 생성되면 절대 사라지지 않음. (인스턴스가 프로그램 종료 시까지 메모리에 상주)
    
    - 명시적인 생명주기 관리가 어려움
    
    - 언리얼 엔진에서 특히 문제가 됨 (게임 상태 변경, 맵 로딩 등의 상황에서 데이터 잔존 문제)

- Subsystem
  
  - 싱글톤의 장점은 유지하면서 단점을 보완한 구조
  
  - 생명주기 : **자신이 속한 상위 객체(Module, World, GameInstance)의 생명주기를 따름**
  
  - 초기화와 종료가 명확
  
  - 다른 Subsystem과의 의존성 관리 용이

##### Game Feature란?

- 언리얼 엔진의 모듈식 게임 기능을 구현하기 위한 시스템

- 게임의 특정 기능들을 독립적으로 개발, 테스트, 배포 가능하게 해주는 프레임워크

- 런타임에서 동적으로 기능를 활성화/비활성화 할 수 있음 (Actions)

- 사용예 ) 어떤 시간에는 해당 스킬 활성화(game feature를 키고 꺼서) 또는 몬스터 스폰이 되도록도 가능!

##### 델리게이트와 이벤트 등록 방식의 차이점

- 델리게이트 방식
  
  - 특정 이벤트 호출 시 바인딩(구독)된 모든 함수들에게 브로드캐스팅

- 이벤트 방식
  
  - 특정 이벤트(Event A)가 발생했을 때 해당 이벤트에 바인딩된 함수들만 호출

##### Cosmetic이란?

- GameFeature 시스템을 활용한 캐릭터 커스터마이징 시스템

- 컴포넌트 기반으로 캐릭터 외형을 동적으로 변경할 수 있음

- 애니메이션 및 이펙트도 컴포넌트로 관리

##### ControllerComponent_CharacterParts랑 PawnComponent_CharacterParts의 차이점

- ControllerComponent_CharacterParts
  
  - Controller에 부착됨
  
  - 어떤 모양을 사용할지를 관리 - 요청은 PawnComponent_CharacterParts에게 함
    
    - 무겁지 않은 메타 데이터만 들고 있음.

- PawnComponent_CharacterParts
  
  - Pawn에 부착됨
  
  - ControllerComponent_CharacterParts에게서 요청받은 메타 데이터를 이용해서 실제 메시 렌더링 (실제 작업)

- 왜 ControllerComponent_CharacterParts를 상속받은 블루프린트(1)는 AddComponent로 붙였는데 PawnComponent_CharacterParts를 상속받은 블루프린트(2)는 캐릭터 자체에다가 붙였을까?
  
  - (1) 같은 경우 메타 데이터를 들고 있어서 별로 무겁지 않음
  
  - (2) 같은 경우 그 자체 값을 들고 있어서 무거움 (Mesh는 무거움)

##### EquipmentDefinition과 InventoryItemDefinition 차이점

- LyraEquipmentDefinition : 장착에 관련된 메타 데이터 담당(어떻게 장착되고 동작할 것인가?)

- InventoryItemDefinition : Fragment 기반의 데이터 구조 (아이템이 어떤 속성들을 가지고 있는가?)

##### Niagara System과 Niagara Particle System Component의 차이점

- Niagara System (레시피)
  
  - 파티클 시스템의 실제 에셋/템플릿입니다
  
  - 컨텐츠 브라우저에서 만들고 편집할 수 있습니다
  
  - 이미터, 파티클 스폰 조건, 업데이트 로직 등 파티클의 동작을 정의합니다
  
  - 재사용 가능한 파티클 시스템의 "청사진"이라고 볼 수 있습니다

- Niagara Particle System Component (실제 요리)
  
  - 액터에 추가할 수 있는 실제 컴포넌트입니다
  
  - Niagara System의 인스턴스를 월드에 스폰하고 실행하는 역할을 합니다
  
  - 트랜스폼, 활성화/비활성화, 파라미터 오버라이드 등을 제어할 수 있습니다
  
  - 레벨에 배치되거나 런타임에 스폰된 실제 파티클 시스템의 "인스턴스"입니다

##### Ability System - 속성 편

- 주로 속성은 캐릭터 쪽에 구현을 많이 했음 (이러다 보니 다중상속도 그렇고 누굴 상속 할지도 애매, ex.마검사)

- 그래서 Lyra에서는 속성을 캐릭터에 넣지 않고 Attribute라는 클래스를 만들어서 넣음
  
  - Attribute : 속성을 부여하기 위한 클래스임
  
  - 속성 자체를 모듈화 해버림.

---
